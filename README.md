# MIPT VK AI LAB
__CoreML: тестовое для МФТИ__

Инструкция по запуску решения:
1) В переменной FOLDER_PATH указать путь до папки с данными
2) Всё :)

В решении я допустил одну оплошность, в связи с которой я не получил отличных от нуля метрик ndcg@1 и ndcg@10 для реализованного мной метода из статьи. Поэтому, возможно, работу нет большого смысла проверять, но и не отправить её я не мог. Оплошность заключалась в том, что при чтении статьи, реализацию перевода implicit матрицы в explicit я решил оставить на потом, а потом, как это часто бывает, я забыл это сделать. Когда всопмнил, уже было поздно. В связи с этим реализованный мной метод отлично предсказывает рейтинги фильмов по заданным userId и movieId, но совершенно неадеватно выдает рекомменадации.

Отчёт:

Данные на train и test я поделил стратифицировано по userId и rating. Такой способ деления данных позволяет получить абсолютно идентичные распредления на train и test. Помимо математической обоснованности такого выбора, за этим стоит также простая логика: при стратификации по userId в train часть попадют все юзеры, а значит в test не встретится юзер о котором мы ничего не знаем; при стратификации по rating в train мы будем знать все предпочтения юзера, то есть будем знать и те фильмы, которые он любит и те, которые он не любит.

Предобработку данных я старался сделать похожей на ту, что была описана в статье:
1) Удалил фильмы, которые были просмотрены меньше, чем 20-ью пользователями (0.07%);
2) Удалил для каждого пользователя рейтинг, который он поставил только 1 раз (0.01%) (необходимо для корректного разделения данных на train и test).

Делить последовательности фильмов на несколько, там где есть большие перерывы, я не стал по двум причинам:
1) По-моему мнению предпочтения пользователей в фильмах не особо меняется со временем;
2) Я не смог найти адекватного порога для деления, так как какие-то рейтинги проставлены с задержкой в 1 у.е., а какие-то в 10^6 у.е. и между этими двумя числами представлены почти все возможные другие числа.

К сожалению сравнить 2 метода я не могу, но ImplicitALS меня впечатлил своей скоростью работы и высокими метриками: ndcg@1 = 0.38, ndcg@10 = 0.36

По логике, описанный в статье метод должен работать лучше, чем ImplicitALS, так как в нём учитывается дополнительная информация в виде похожести фильмов, в отличие от ImplicitALS.
